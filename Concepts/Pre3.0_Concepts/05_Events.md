# 5. Events

**Release 3.3** — Copyright ©1995 by NeXT Computer, Inc. All Rights Reserved.

> Changes made for the current release of NeXTstep affect the information presented in this chapter. For details see:
> - `/NextLibrary/Documentation/NextDev/ReleaseNotes/WindowServer.rtf`
> - `/NextLibrary/Documentation/NextDev/ReleaseNotes/AppKit.rtf`

## Overview

Applications on the NeXT computer respond to four types of input:

1. **Events** - Direct or indirect reports of a user's actions (key-down and mouse-up events, for example)
2. **Timed entries** - Functions that are executed at a given frequency
3. **Data received at a Mach port** - Inter-process communication
4. **Data waiting at a file descriptor** - File or device I/O

Of these four, events are by far the most prevalent and important. The heart of an application is its event loop, the routine that repeatedly checks for the arrival of new events. It's only when the application is running the event loop that it can receive input from the three other sources.

This chapter begins with an examination of events: their types, components, and how they're distributed to an application. It then discusses the other types of input and how an application coordinates its response to them.

---

## Event Basics

Applications on the NeXT computer are driven by the user's actions on the keyboard and mouse. The Window Server treats each user action as an event, which it associates with a window and reports to the application that created the window.

For most events, the Window Server sends the event to the application only if the window's event mask permits it. The mask has a different bit set for each type of event the application is interested in.

Pertinent information about each event—such as which character was typed and where the mouse was located—is collected in an event record. When an event is reported to an application, its record is stored in a C structure and made available to the application through the Application Kit.

Since an application and the Window Server are separate processes that execute asynchronously, a system is needed to coordinate their communication. As event records are received in the application, they're temporarily placed in storage called the event queue. When the application is ready to process an event, it takes an event record from the queue. Only when the application checks the queue can it also check for timed entries or data at a Mach port or in a file.

Most events follow the same path: from the Window Server to the application's event queue, and from there, to the objects and functions of the application.

---

## Types of Events

The different types of events an application receives can be grouped into seven categories:

1. **Keyboard events** - Key presses, releases, and modifier key changes
2. **Mouse events** - Button presses, releases, and cursor movement
3. **Timer events** - Periodic notifications
4. **Cursor-update events** - Cursor position changes over defined areas
5. **Kit-defined events** - Internal application framework events
6. **System-defined events** - System-level events like power-off
7. **Application-defined events** - Custom events defined by the application

### Keyboard Events

Direct reports of the user's keyboard actions include:

- **Key-down event** - Generated when the user presses a key
- **Key-up event** - Generated when the key is released
- **Flags-changed event** - Generated when the user presses or releases Alternate, Shift, Control, or Command key, or turns Alpha Lock on or off

Key-down events are the most useful to the application. Key-up events are less used since they follow almost automatically when there has been a key-down event.

### Mouse Events

Mouse events are generated by changes in the state of the mouse buttons and by changes in the position of the mouse cursor on the screen:

- **Mouse-down/Mouse-up events** - For both left and right mouse buttons
- **Mouse-dragged events** - For movement with button held down
- **Mouse-moved events** - For cursor movement without buttons pressed
- **Mouse-entered/Mouse-exited events** - When cursor enters/leaves tracking rectangles

### Timer Events

A timer event notifies an application that a certain time interval has elapsed. Applications can register to receive timer events at a given frequency and later turn them off.

### Cursor-Update Events

A cursor-update event informs an application that the cursor has crossed the boundary of a predefined rectangular area within a window, allowing the application to update the cursor's shape.

### Kit-Defined Events

Kit-defined events contain information that the Application Kit uses to manage your application. These include:

- Window-moved subevent
- Window-resized subevent
- Window-exposed subevent
- Application-activated/deactivated subevents

### System-Defined Events

Currently, there's only one subevent: the power-off subevent, generated when the user presses the Power key.

### Application-Defined Events

Application-defined events are compound events with no predefined subevent types. Applications can define as many subevent types as needed.

---

## The Event Record

Information about each event is stored in an event record. When the application sees it, the event record has the following structure (defined in `dpsclient/event.h`):

```c
typedef struct _NXEvent {
    int           type;        /* event type */
    NXPoint       location;    /* mouse location */
    long          time;        /* time since startup */
    int           flags;       /* key state flags */
    unsigned int  window;      /* window number */
    NXEventData   data;        /* type-specific information */
    DPSContext    ctxt;        /* context number */
} NXEvent;
```

### Event Record Components

| Component | Content |
|-----------|---------|
| `type` | The event type (mouse-down, key-up, kit-defined, etc.) |
| `location` | The mouse location (x, y coordinates in window's base coordinate system) |
| `time` | Time elapsed since system startup (in vertical retrace intervals) |
| `flags` | Modifier key states (Shift, Command, Control, Alternate, Alpha Lock) |
| `window` | The window number associated with the event |
| `data` | Type-specific information (union containing different data depending on event type) |
| `ctxt` | The PostScript context number |

### Event Types

| Constant | Event Type |
|----------|-----------|
| NX_KEYDOWN | Key-down |
| NX_KEYUP | Key-up |
| NX_FLAGSCHANGED | Flags-changed |
| NX_LMOUSEDOWN | Mouse-down, left button |
| NX_LMOUSEUP | Mouse-up, left button |
| NX_RMOUSEDOWN | Mouse-down, right button |
| NX_RMOUSEUP | Mouse-up, right button |
| NX_MOUSEMOVED | Mouse-moved |
| NX_LMOUSEDRAGGED | Mouse-dragged, left button |
| NX_RMOUSEDRAGGED | Mouse-dragged, right button |
| NX_MOUSEENTERED | Mouse-entered |
| NX_MOUSEEXITED | Mouse-exited |
| NX_TIMER | Timer |
| NX_CURSORUPDATE | Cursor-update |
| NX_KITDEFINED | Kit-defined |
| NX_SYSDEFINED | System-defined |
| NX_APPDEFINED | Application-defined |

### Event Flags

The flags component contains modifier key states. Only the high-order flags are hardware-independent:

| Mask | Event Flag |
|------|-----------|
| NX_ALPHASHIFTMASK | Alpha Lock or any Shift key down |
| NX_SHIFTMASK | Any Shift key down |
| NX_CONTROLMASK | Any Control key down |
| NX_ALTERNATEMASK | Any Alternate key down |
| NX_COMMANDMASK | Any Command key down |
| NX_NUMERICPADMASK | Key is on numeric keypad |

### Type-Specific Event Data

The data component is a C union containing different information depending on event type:

```c
typedef union {
    /* For mouse-down and mouse-up events: */
    struct {
        short  reserved;
        short  eventNum;     /* event number */
        int    click;        /* single, double, triple, etc. */
        int    unused;
    } mouse;

    /* For key-down and key-up events: */
    struct {
        short            reserved;
        short            repeat;      /* key repeat indicator */
        unsigned short   charSet;     /* character set */
        unsigned short   charCode;    /* character code */
        unsigned short   keyCode;     /* key code */
        short            keyData;     /* hardware-dependent data */
    } key;

    /* For mouse-entered and mouse-exited events: */
    struct {
        short  reserved;
        short  eventNum;          /* mouse-down event number */
        int    trackingNum;       /* tracking rectangle number */
        int    userData;          /* programmer-determined data */
    } tracking;

    /* For kit-defined, sys-defined, and app-defined events */
    struct {
        short  reserved;
        short  subtype;  /* subevent type for compound events */
        union {
            float  F[2];
            long   L[2];
            short  S[4];
            char   C[8];
        } misc;
    } compound;
} NXEventData;
```

### Keyboard Information

For every keyboard event, the data component specifies the character that was typed, by indicating the character set and character code:

- **NX_ASCIISET** - Standard (extension of ASCII)
- **NX_SYMBOLSET** - Symbol font

Each character set has an encoding vector that maps the character code to a particular character. The character information in the event record incorporates the effect of Alternate, Shift, Control, and Alpha Lock (Command-Shift), but not necessarily Command.

---

## Event Masks

Each window has an event mask maintained by the Window Server. The mask is a long integer with a bit assigned to each event type. If the bit for a given type is 0, no events of that type will be sent to the application.

When a window is created by the Window Server, it has a mask that allows all but mouse-moved, mouse-dragged, and flags-changed events. A standard window created with the Application Kit has an event mask that includes:

- Key-down and key-up
- Left and right mouse-down and mouse-up
- Mouse-entered and mouse-exited
- Kit-defined and system-defined events
- Application-defined events

### Event Mask Constants

| Constant | Event Type |
|----------|-----------|
| NX_KEYDOWNMASK | Key-down |
| NX_KEYUPMASK | Key-up |
| NX_FLAGSCHANGEDMASK | Flags-changed |
| NX_LMOUSEDOWNMASK | Mouse-down, left |
| NX_LMOUSEUPMASK | Mouse-up, left |
| NX_RMOUSEDOWNMASK | Mouse-down, right |
| NX_RMOUSEUPMASK | Mouse-up, right |
| NX_MOUSEMOVEDMASK | Mouse-moved |
| NX_LMOUSEDRAGGEDMASK | Mouse-dragged, left |
| NX_RMOUSEDRAGGEDMASK | Mouse-dragged, right |
| NX_MOUSEENTEREDMASK | Mouse-entered |
| NX_MOUSEEXITEDMASK | Mouse-exited |
| NX_TIMERMASK | Timer |
| NX_CURSORUPDATEMASK | Cursor-update |
| NX_KITDEFINEDMASK | Kit-defined |
| NX_SYSDEFINEDMASK | System-defined |
| NX_APPDEFINEDMASK | Application-defined |
| NX_ALLEVENTS | All event types |

---

## The Event Queue

Events are returned from the Window Server over a bidirectional communication channel. As the Window Server creates each event record, it's dispatched to the application process. When the event record arrives, it's added to the application's event queue.

The event queue is a ring buffer that can hold a maximum of 50 events. If event records are consistently added faster than the application can remove them, the capacity can be reached. In this case, a new event record replaces the oldest one in the queue.

For applications based on the Application Kit, event records are taken from the queue and returned to the application whenever the main event loop is executing. Applications that don't use the Application Kit must access the event queue directly using functions like `DPSGetEvent()` and `DPSPeekEvent()`.

---

## Event-Related Services

The client library routines that manage the event queue can also provide other services to an application:

- **Execute a timed entry** - DPSAddTimedEntry()
- **Monitor a Mach port for messages** - DPSAddPort()
- **Monitor a file descriptor for data** - DPSAddFD()

For each service, you register a function that you want called when the corresponding condition is met. The registered functions take different arguments depending on which service has been requested. They have an argument in common: `void *`, which you can use to pass information to the function.

---

## Executing Timed Entries

A timed entry is a function specified to be called at a given frequency. You register a function as a timed entry by calling `DPSAddTimedEntry()`. The arguments include:

- The function to be called
- The time interval between calls
- An arbitrary piece of data to be passed to the function
- A priority level

Since you can have more than one function registered as a timed entry, each call to `DPSAddTimedEntry()` returns a unique registration number. When a specific timed entry is no longer needed, it's eliminated by calling `DPSRemoveTimedEntry()` with the timed entry's registration number.

Example timed entry function:

```c
void printIt(DPSTimedEntry teNum, double now, void *userData)
{
    char *theChar = userData;
    printf("%c\n", *theChar);
}
```

### Interval Variability

The interval you set for the timed entry is only a request to the system. The actual interval depends on several factors:

- A timed entry is called only when the application is waiting for events
- If a program routine involves a long computation, no timed entry executes until it finishes
- Multiple timed entries can interfere with each other
- The resolution of the system clock affects execution frequency
- Process suspension in a multitasking environment can cause overdue execution

For simulations requiring accurate timing, calculate the state relative to absolute system time passed as an argument to the function.

---

## Checking Mach Ports

An application can use a Mach port as a conduit for communication with other applications. `DPSAddPort()` adds a port to the list of ports that the application can check when getting events. It also registers a function to be called when a message is received.

---

## Checking File Descriptors

Applications can also communicate by sending data to or receiving it from a file. The file is represented by an integer called a file descriptor. `DPSAddFD()` adds a file descriptor to the list of those the application checks each time it attempts to retrieve an event.

---

## Scheduling

Whether a timed entry is called, or a port or file descriptor is checked, depends on the priority level assigned to the registered function. The priority level is an integer from 0 to 30, with 30 as the highest possible priority and 0 as the lowest.

Whenever an application checks for an event, it specifies a priority threshold. Registered functions with priorities lower than the threshold are screened out; all those with equal or higher priorities are checked at least once.

**Priority Levels and Thresholds:**

- Priority 0 blocks function from ever being called
- Priority 1-30 can be checked depending on threshold
- Threshold 1 (normal) allows functions with priority 1 or higher
- Threshold 31 (maximum) blocks all procedure calls
- A function's priority is compared only to the threshold, not to other functions' priorities

---

## Summary

Events are the primary mechanism by which applications respond to user actions. The Window Server generates events from keyboard and mouse activity, and the application processes them through an event loop. The event queue buffers incoming events, and the application can also register for timed entries, Mach port messages, and file descriptor data. Together, these mechanisms provide a flexible system for responsive, interactive applications.
